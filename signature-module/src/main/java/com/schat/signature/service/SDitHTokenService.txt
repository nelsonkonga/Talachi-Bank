package com.schat.signature.service;

import com.schat.signature.core.*;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Base64;

@Service
public class SDitHTokenService {
    private final SDitHSigner signer;
    private final SDitHKeyPair keyPair;
    private final SecretKey jwtSigningKey;

    public SDitHTokenService() {
        this.signer = new SDitHSigner();

        // Generating SDitH key pair (128-bit security)..
        SDitHParameters params = new SDitHParameters(SDitHParameters.SECURITY_LEVEL_128);
        this.keyPair = signer.generateKeyPair(params);

        // Deriving JWT signing key from SDitH private key..
        this.jwtSigningKey = deriveJwtKey(keyPair.getPrivateKey());
    }

    /**
     * To Generate a JWT token with SDitH signature..
     */
    public String generateToken(String subject, Map<String, Object> claims, long expirationMs) {
        Date now = new Date();
        Date expiration = new Date(now.getTime() + expirationMs);

        // Build JWT with claims..
        Map<String, Object> allClaims = new HashMap<>(claims);

        String jwt = Jwts.builder()
                .subject(subject)
                .claims(allClaims)
                .issuedAt(now)
                .expiration(expiration)
                .signWith(jwtSigningKey, Jwts.SIG.HS256)
                .compact();

        // Generating SDitH signature of the JWT..
        byte[] jwtBytes = jwt.getBytes(StandardCharsets.UTF_8);
        byte[] sdithSignature = signer.sign(jwtBytes, keyPair.getPrivateKey());

        // Encoding signature and append to JWT..
        String encodedSignature = Base64.getUrlEncoder().withoutPadding()
                .encodeToString(sdithSignature);

        return jwt + "." + encodedSignature;
    }

    /**
     * To Verify and parse a token with SDitH signature..
     */
    public Claims verifyToken(String signedToken) {
        try {
            // Splitting JWT and SDitH signature..
            String[] parts = signedToken.split("\\.");
            if (parts.length != 4) { // header.payload.jwtSig.sdithSig
                throw new JwtException("Invalid token format");
            }

            String jwt = parts[0] + "." + parts[1] + "." + parts[2];
            String sdithSigEncoded = parts[3];

            // Decoding SDitH signature..
            byte[] sdithSignature = Base64.getUrlDecoder().decode(sdithSigEncoded);

            // Verifying SDitH signature..
            byte[] jwtBytes = jwt.getBytes(StandardCharsets.UTF_8);
            if (!signer.verify(jwtBytes, sdithSignature, keyPair.getPublicKey())) {
                throw new JwtException("SDitH signature verification failed");
            }

            // Verifying JWT signature and parse..
            return Jwts.parser()
                    .verifyWith(jwtSigningKey)
                    .build()
                    .parseSignedClaims(jwt)
                    .getPayload();

        } catch (Exception e) {
            throw new JwtException("Token verification failed: " + e.getMessage(), e);
        }
    }

    /**
     * To Extract subject from token without full verification (tbu with caution)..
     */
    public String extractSubject(String token) {
        return verifyToken(token).getSubject();
    }

    /**
     * To Check if token is expired..
     */
    public boolean isTokenExpired(String token) {
        try {
            Claims claims = verifyToken(token);
            return claims.getExpiration().before(new Date());
        } catch (Exception e) {
            return true;
        }
    }

    /**
     * To Get public key for verification (to share with other services)..
     */
    public String getPublicKeyBase64() {
        return keyPair.getPublicKey().toBase64();
    }

    private SecretKey deriveJwtKey(SDitHKeyPair.SDitHPrivateKey privateKey) {
        try {
            // Deriving a symmetric key from SDitH private key using SHA-256..
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(privateKey.getSecretKey());
            return Keys.hmacShaKeyFor(hash);
        } catch (Exception e) {
            throw new RuntimeException("Failed to derive JWT key", e);
        }
    }
}
